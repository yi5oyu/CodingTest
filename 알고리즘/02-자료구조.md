<div align="center">

# **자료구조**
  
데이터를 효율적으로 저장하고 관리하기 위한 방법

</div>

## 분류

```
자료구조
 - 선형 구조(Linear Structure)
  : 배열(Array)
  : 연결 리스트(Linked List)
  : 스택(Stack)
  : 큐(Queue)
 - 비선형 구조(Non-linear Structure)
  : 트리(Tree)
  : 그래프(Graph)
  : 해시 테이블(Hash Table)
```

## 선형 자료구조

### 배열

`같은 타입의 데이터를 연속된 메모리 공간에 저장하는 자료구조`

```
접근: O(1), 삽입/삭제: O(n)

   [0]    [1]    [2]    [3]   - 인덱스
┌──────┬──────┬──────┬──────┐
│  10  │  20  │  30  │  40  │ - 데이터
└──────┴──────┴──────┴──────┘
 0x100  0x104  0x108  0x10C   - 메모리   

```

### 연결 리스트

`노드(Node)들이 포인터로 연결된 동적 자료구조`

```
접근: O(n), 삽입/삭제: O(1)

1. 단일 연결 리스트(Singly Linked List)
 - 각 노드가 다음 노드만을 가리킴(단방향)

  노드1     노드2      노드3     노드4 
┌──────┐  ┌──────┐  ┌──────┐  ┌──────┐   
│  10  │  │  20  │  │  30  │  │  40  │  - 데이터  
├──────┤  ├──────┤  ├──────┤  ├──────┤  
│0x2000┼─→│0x3000┼─→│0x4000┼─→│ NULL │  - 포인터
└──────┘  └──────┘  └──────┘  └──────┘   
 0x1000    0x2000    0x3000    0x4000   - 메모리

2. 이중 연결 리스트(Doubly Linked List)
 - 각 노드가 이전과 다음 노드를 모두 가리킴(양방향)

  노드1     노드2      노드3     노드4 
┌──────┐  ┌──────┐  ┌──────┐  ┌──────┐   
│ NULL │←─┼0x1000│←─┼0x2000│←─┼0x3000│  - 포인터(이전 노드)
├──────┤  ├──────┤  ├──────┤  ├──────┤   
│  10  │  │  20  │  │  30  │  │  40  │  - 데이터  
├──────┤  ├──────┤  ├──────┤  ├──────┤  
│0x2000┼─→│0x3000┼─→│0x4000┼─→│ NULL │  - 포인터(다음 노드)
└──────┘  └──────┘  └──────┘  └──────┘   
 0x1000    0x2000    0x3000    0x4000   - 메모리

3. 원형 연결 리스트(Circular Linked List)
 - 마지막 노드가 첫 번째 노드를 가리킴

- 단일 원형 연결 리스트

      노드1     노드2      노드3     노드4 
    ┌──────┐  ┌──────┐  ┌──────┐  ┌──────┐   
    │  10  │  │  20  │  │  30  │  │  40  │  - 데이터  
    ├──────┤  ├──────┤  ├──────┤  ├──────┤  
  ┌→│0x2000┼─→│0x3000┼─→│0x4000┼─→│0x1000┼┐ - 포인터
  | └──────┘  └──────┘  └──────┘  └──────┘|
  └───────────────────────────────────────┘
     0x1000    0x2000    0x3000    0x4000   - 메모리

- 이중 원형 연결 리스트

      노드1     노드2      노드3     노드4
   ┌───────────────────────────────────────┐ 
   |┌──────┐  ┌──────┐  ┌──────┐  ┌──────┐ |   
   └┼0x4000│←─┼0x1000│←─┼0x2000│←─┼0x3000┼←┘ - 포인터(이전 노드)
    ├──────┤  ├──────┤  ├──────┤  ├──────┤   
    │  10  │  │  20  │  │  30  │  │  40  │   - 데이터  
    ├──────┤  ├──────┤  ├──────┤  ├──────┤  
  ┌→│0x2000┼─→│0x3000┼─→│0x4000┼─→│0x1000┼┐  - 포인터(다음 노드)
  | └──────┘  └──────┘  └──────┘  └──────┘|
  └───────────────────────────────────────┘
     0x1000    0x2000    0x3000    0x4000    - 메모리

```

### 스택

`LIFO(Last In, First Out), 한쪽 끝에서만 삽입과 삭제`

```
Push/Pop/Peek: O(1), Search: O(n)

                  Push(40)   Peek()     Pop()
           TOP     40 삽입   40 반환   40 반환 후 제거
        ┌──────┐  ┌──────┐  ┌──────┐  ┌──────┐
 0x1008 |  30  │  |  40  │  |  40  │  |  30  │
        ├──────┤  ├──────┤  ├──────┤  ├──────┤
 0x1004 │  20  │  │  30  │  │  30  │  │  20  │  
        ├──────┤  ├──────┤  ├──────┤  ├──────┤
 0x1000 │  10  │  │  20  │  │  20  │  │  10  │
        └──────┘  ├──────┤  ├──────┤  └──────┘
         BOTTOM   │  10  │  │  10  │
                  └──────┘  └──────┘
```

### 큐

`FIFO(First In, First Out), 한쪽 끝에서 삽입, 다른 쪽 끝에서 삭제`

```
Enqueue/Dequeue: O(1), Search: O(n)

1. 선형 큐 (Linear Queue)
 - 배열로 구현(크기 제한)

Front Rear                   Front                Rear
  앞   뒤                      앞                  뒤
 [0]  [1]  [2]  [3]  [4]      [0]  [1]  [2]  [3]  [4] 
┌────┬────┬────┬────┬────┐   ┌────┬────┬────┬────┬────┐
│ 10 │ 20 │    │    │    │ → │ -- │ -- │ 30 │ 40 │ 50 │
└────┴────┴────┴────┴────┘   └────┴────┴────┴────┴────┘
                              사용후 빈 공간 발생

2. 원형 큐 (Circular Queue)
 - 배열의 마지막과 처음이 연결된 형태(메모리 효율성)

- 처음 큐 생성
   F,R
   [0]  [1]  [2]  [3]  [4]   
  ┌────┬────┬────┬────┬────┐ 
  │    │    │    │    │    │ 
  └────┴────┴────┴────┴────┘ 
- 삽입: Enqueue(10), Enqueue(20)
    F    R                       F         R
     (0+1) % 5                         (1+1) % 5 
   [0]  [1]  [2]  [3]  [4]      [0]  [1]  [2]  [3]  [4]   
  ┌────┬────┬────┬────┬────┐   ┌────┬────┬────┬────┬────┐ 
  │    │ 10 │    │    │    │   │    │ 10 │ 20 │    │    │ 
  └────┴────┴────┴────┴────┘   └────┴────┴────┴────┴────┘ 
- 삭제: Dequeue() 
         F    R
     (0+1) % 5
   [0]  [1]  [2]  [3]  [4]   
  ┌────┬────┬────┬────┬────┐ 
  │    │ -- │ 20 │    │    │ 
  └────┴────┴────┴────┴────┘
- 삽입: Enqueue(30), Enqueue(40), Enqueue(50)
    R    F          
   [0]  [1]  [2]  [3]  [4]   
  ┌────┬────┬────┬────┬────┐ 
  │ 50 │ -- │ 20 │ 30 │ 40 │ 
  └────┴────┴────┴────┴────┘
> 한 칸 비워서 빈 큐와 가득찬 큐 구분
> 전체 다 쓰려면 count 변수로 원소 개수 확인(연산마다 업데이트 필요)

3. 우선순위 큐 (Priority Queue)
 - 각 요소에 우선순위 부여

- 배열: Enqueue: O(1), Dequeue: O(n)

- 삽입: Enqueue(A(우선순위:3)), Enqueue(B(우선순위:1))
   [0]  [1]  [2]  [3]  [4]     [0]  [1]  [2]  [3]  [4]
  ┌────┬────┬────┬────┬────┐  ┌────┬────┬────┬────┬────┐
  │A(3)│    │    │    │    │  │A(3)│B(1)│    │    │    │    
  └────┴────┴────┴────┴────┘  └────┴────┴────┴────┴────┘
- 삭제: Dequeue() / 전체 탐색: 우선순위 높은 데이터 반환
   [0]  [1]  [2]  [3]  [4]
  ┌────┬────┬────┬────┬────┐
  │A(3)│ -- │    │    │    │  B(1) 반환
  └────┴────┴────┴────┴────┘

- 힙: Enqueue/Dequeue: O(log n)

.

4. 덱 (Deque, Double-ended Queue)
 - 양쪽 끝에서 삽입과 삭제 모두 가능

addFront, addRear, removeFront, removeRear

- 초기 배열
              F         R
   [0]  [1]  [2]  [3]  [4]  [5]  [6]
  ┌────┬────┬────┬────┬────┬────┬────┐
  │    │    │ 30 │ 40 │ 50 │    │    │
  └────┴────┴────┴────┴────┴────┴────┘
- 삽입: addFront(20), addRear(60)
         F              R                        F                  R
   [0]  [1]  [2]  [3]  [4]  [5]  [6]      [0]  [1]  [2]  [3]  [4]  [5]  [6]
  ┌────┬────┬────┬────┬────┬────┬────┐   ┌────┬────┬────┬────┬────┬────┬────┐
  │    │ 20 │ 30 │ 40 │ 50 │    │    │   │    │ 20 │ 30 │ 40 │ 50 │ 60 │    │
  └────┴────┴────┴────┴────┴────┴────┘   └────┴────┴────┴────┴────┴────┴────┘
- 삭제: removeFront(), removeRear()
              F              R                        F        R
   [0]  [1]  [2]  [3]  [4]  [5]  [6]      [0]  [1]  [2]  [3]  [4]  [5]  [6]
  ┌────┬────┬────┬────┬────┬────┬────┐   ┌────┬────┬────┬────┬────┬────┬────┐
  │    │ -- │ 30 │ 40 │ 50 │ 60 │    │   │    │ -- │ 30 │ 40 │ 50 │ -- │    │
  └────┴────┴────┴────┴────┴────┴────┘   └────┴────┴────┴────┴────┴────┴────┘
       20 반환                                                    60 반환

```

<!--원형 텍 -->

## 비선형 자료구조

### 트리

`계층적 구조를 가진 노드들의 집합으로, 루트 노드에서 시작하여 자식 노드들로 뻗어나가는 자료구조`

```
루트(Root), 부모(Parent), 자식(Child), 형제(Sibling), 리프(Leaf), 깊이(Depth), 높이(Height)

1. 이진 트리(Binary Tree)
 - 각 노드가 최대 2개의 자식 노드를 가짐

     10 (루트)
     /  \ (노드)
    5    15
   / \   / \
  3   7 12  20 (리프)

2. 이진 탐색 트리(Binary Search Tree, BST)
 - 왼쪽 자식 < 부모 < 오른쪽 자식

탐색/삽입/삭제: 평균 O(log n), 최악 O(n)

- 삽입: 13, 90 추가
      15
     /  \
    10   20
   / \   / \
  8  12 17  25
      \      \
      13      90

```

### 그래프

``

```

```

### 해시 테이블

``

```

```
