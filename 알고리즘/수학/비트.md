<div align="center">

# **비트**

컴퓨터가 데이터를 저장하는 가장 작은 단위  
0, 1 값

</div>

## 비트 연산

1. **빠른 속도** - CPU가 직접 처리하므로 매우 빠름
2. **메모리 절약** - boolean 배열 대신 비트로 상태 표현
3. **간결한 코드** - 복잡한 조건을 간단히 표현

## 비트 연산자

### 1. AND 연산자 (&)
두 비트가 모두 1일 때만 1

```java
int a = 5;  // 0101
int b = 3;  // 0011
int c = a & b;  // 0001 = 1

System.out.println(c);  // 1
```

**활용:**
```java
// 특정 비트가 1인지 확인
int num = 5;  // 0101
if ((num & (1 << 2)) != 0) {  // 2번 비트 확인
    System.out.println("2번 비트가 1입니다");
}

// 짝수/홀수 판별 (최하위 비트 확인)
if ((num & 1) == 0) {
    System.out.println("짝수");
} else {
    System.out.println("홀수");
}
```

### 2. OR 연산자 (|)
두 비트 중 하나라도 1이면 1

```java
int a = 5;  // 0101
int b = 3;  // 0011
int c = a | b;  // 0111 = 7

System.out.println(c);  // 7
```

**활용:**
```java
// 특정 비트를 1로 설정
int num = 5;  // 0101
num = num | (1 << 1);  // 1번 비트를 1로
System.out.println(num);  // 0111 = 7
```

### 3. XOR 연산자 (^)
두 비트가 다르면 1, 같으면 0

```java
int a = 5;  // 0101
int b = 3;  // 0011
int c = a ^ b;  // 0110 = 6

System.out.println(c);  // 6
```

**XOR의 특별한 성질:**
```java
// 1. 자기 자신과 XOR하면 0
a ^ a = 0

// 2. 0과 XOR하면 자기 자신
a ^ 0 = a

// 3. 교환법칙, 결합법칙 성립
a ^ b = b ^ a
(a ^ b) ^ c = a ^ (b ^ c)

// 4. 두 번 XOR하면 원래 값으로 복원 (암호화/복호화)
a ^ b ^ b = a
```

**활용 예제:**
```java
// 값 교환 (swap without temp variable)
int a = 5, b = 3;
a = a ^ b;
b = a ^ b;  // b = (a ^ b) ^ b = a
a = a ^ b;  // a = (a ^ b) ^ a = b
System.out.println("a=" + a + ", b=" + b);  // a=3, b=5

// 배열에서 한 번만 등장하는 숫자 찾기
int[] arr = {1, 2, 3, 2, 1};
int result = 0;
for (int num : arr) {
    result ^= num;  // 같은 숫자끼리는 0이 됨
}
System.out.println(result);  // 3
```

### 4. NOT 연산자 (~)
비트 반전 (0→1, 1→0)

```java
int a = 5;  // 0000 0101
int b = ~a;  // 1111 1010 = -6 (2의 보수)

System.out.println(b);  // -6
```

**주의:** Java는 부호 있는 정수를 사용하므로 최상위 비트가 부호 비트

### 5. 왼쪽 시프트 (<<)
비트를 왼쪽으로 이동 (2를 곱하는 효과)

```java
int a = 5;  // 0000 0101
int b = a << 1;  // 0000 1010 = 10
int c = a << 2;  // 0001 0100 = 20

System.out.println(b);  // 10 (5 * 2)
System.out.println(c);  // 20 (5 * 4)
```

**활용:**
```java
// 2의 거듭제곱 계산
int power = 1 << 10;  // 2^10 = 1024

// n번째 비트만 1인 수
int bit = 1 << n;
```

### 6. 오른쪽 시프트 (>>, >>>)

**>> (산술 시프트):** 부호 비트 유지
```java
int a = -8;  // 1111 1000
int b = a >> 2;  // 1111 1110 = -2
System.out.println(b);  // -2
```

**>>> (논리 시프트):** 0으로 채움
```java
int a = -8;  // 1111 1000
int b = a >>> 2;  // 0011 1110
System.out.println(b);  // 양수
```

---
