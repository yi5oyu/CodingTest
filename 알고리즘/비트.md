<div align="center">

# **비트**

컴퓨터가 데이터를 저장하는 가장 작은 단위  
0, 1 값

</div>

## 진수 변환

```java
// 2진수 리터럴
int binary = 0b1010;  // 10

// 10진수 → 2진수 문자열
String bin = Integer.toBinaryString(10);  // "1010"

// 2진수 문자열 → 10진수
int dec = Integer.parseInt("1010", 2);  // 10
```

## 비트 연산

`AND OR NOT XOR >> <<`

### AND 연산자 

`&`: 둘 다 1일 때만 1

```java
int a = 5;  // 0101
int b = 3;  // 0011
int num = a & b;  // 0001 = 1

// 짝수/홀수 판별 (% 연산보다 빠름)
if ((num & 1) == 0) {
    System.out.println("짝수");
} else {
    System.out.println("홀수");
}

// 특정 비트가 켜져있는지 확인
if ((a & (1 << 2)) != 0) {
    System.out.println("2번 비트가 1입니다");
}
```

### OR 연산자

`|`: 하나라도 1이면 1

```java
int a = 5;  // 0101
int b = 3;  // 0011
int num = a | b;  // 0111 = 7

// 특정 비트를 1로 설정 (1번 비트 켜기)
a = a | (1 << 1);  // 0111 = 7

// 비트 마스크로 집합 표현
int set = 0;
set |= (1 << 2);  // 2 추가
set |= (1 << 5);  // 5 추가
// set = {2, 5}
```

### NOT 연산자

`~`: 비트 반전 (0→1, 1→0)

```java
int a = 5;   // 0000 0101
int b = ~a;  // 1111 1010 = -6 (2의 보수)

// 특정 비트를 0으로 끄기
int value = 7;  // 0111
value = value & ~(1 << 1);  // 0101 = 5

// 하위 3비트만 추출
int num = 0b11010;
int lower = num & ~(~0 << 3);  // 0b010 = 2
// ~0: 모든 비트가 1이됨
// ~0 << 3: 맨 오른쪽 3비트만 0이 됨
// ~(~0 << 3): 다시 반전되 오른쪽 3비트만 1이 됨

// 부호 반전 (2의 보수)
int ax = ~a + 1;  // -5
```

### XOR 연산자

`^`: 서로 다르면 1, 같으면 0

```java
int a = 5;  // 0101
int b = 3;  // 0011
int num = a ^ b;  // 0110 = 6

num = num ^ num   // 0
num = num ^ 0     // num(0110)

// 비트 토글
a = a ^ (1 << 1);  // 0111 = 7
a = a ^ (1 << 1);  // 0101 = 5(원래대로)

// swap(임시 변수 없이 가능)
a ^= b; // a = a ^ b;
b ^= a; // b = b ^ a; : b = b^(a^a) = a = 5
a ^= b; // a = a ^ b; : a = (a^b)^a = b = 3

// 배열에서 한 번만 등장하는 숫자 찾기
int[] arr = {1, 2, 3, 2, 1};
int result = 0;
for (int n : arr) {
    result ^= n;  // 같은 수끼리는 0이 됨
}
```

### 왼쪽 시프트

`<<`: 비트를 왼쪽으로 이동(×2 효과)

```java
int a = 5;  // 0000 0101
int b = a << 1;  // 0000 1010 = 10
int c = a << 2;  // 0001 0100 = 20
int d = a << 3;  // 0010 1000 = 40

// 2의 거듭제곱 계산
int power = 1 << 10;  // 2^10 = 1024

// n번째 비트만 1인 마스크
int mask = 1 << 3;  // 0b1000 = 8

// 하위 n비트 모두 1 만들기
int allOnes = (1 << 4) - 1;  // 0b1111 = 15

// 곱셈 최적화
int multiply = 5 << 3;  // 5 * 2^3 = 40
```

### 오른쪽 시프트

`>>`: 산술 시프트(부호 유지, ÷2 효과)  
`>>>`: 논리 시프트(0으로 채움)

```java
// 산술 시프트(>>)
int a = 8;  // 0000 1000
int b = a >> 1;  // 0000 0100 = 4
int c = a >> 2;  // 0000 0010 = 2

// 음수의 경우 부호 유지
int ax = -8;  // 1111 1000
int d = ax >> 2;  // 1111 1110 = -2

// 논리 시프트(>>>)
int e = -8;  // 1111 1000
int f = e >>> 2;  // 0011 1110(양수로 바뀜)

// 나눗셈 최적화
int divide = 40 >> 3;  // 40 / 2^3 = 5

// 이진 탐색에서 중간값
int left = 0, right = 100;
int mid = (left + right) >> 1;  // (left + right) / 2

// 비트 순회
int num = 5;
for (int i = 3; i >= 0; i--) {
    System.out.print((num >> i) & 1);  // 0101
}
```

## 사용

### 비트 카운팅

```java
// Integer.bitCount() 사용
int count = Integer.bitCount(5);  // 2개 (0101)

int n = 5;
int bits = 0;
while (n > 0) {
    n &= (n - 1);  // 가장 오른쪽 1 제거
    bits++;
}

// 최하위 1비트만 추출
int num = 12;  // 1100
int lowest = num & -num;  // 0100 = 4
// -num = ~num + 1(0011 + 1 = 0100)

// 최상위 비트 위치
int highest = 31 - Integer.numberOfLeadingZeros(5);  // 2
```

### 2의 거듭제곱 확인

```java
int num = 8;
// 2^k는 한 비트만 1(8 = 1000)
// num-1은 그 아래 비트가 모두 1(7 = 0111)
if (num > 0 && (num & (num - 1)) == 0) {
    System.out.println(num + "은 2의 거듭제곱");
}
```

### 부분집합 생성

```java
int[] arr = {1, 2, 3};
int n = arr.length;

// 2^n가지 부분집합
for (int mask = 0; mask < (1 << n); mask++) {
    for (int i = 0; i < n; i++) {
        if ((mask & (1 << i)) != 0) {
            System.out.print(arr[i] + " ");
        }
    }
}
```

### 비트 DP
```java
// visited: 방문한 도시를 비트로 표현
int visited = 0;
int current = 0;

// 0번 도시 방문
visited |= (1 << 0);

// 2번 도시 방문 여부 확인
if ((visited & (1 << 2)) == 0) {
    System.out.println("2번 미방문");
}

// 모든 도시 방문 확인 (n개)
int n = 4;
if (visited == (1 << n) - 1) {
    System.out.println("모든 도시 방문 완료");
}
```
