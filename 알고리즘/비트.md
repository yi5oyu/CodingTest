

## 진수

```java
// 2진수 리터럴
int binary = 0b1010;  // 10

// 10진수 → 2진수 문자열
String bin = Integer.toBinaryString(10);  // "1010"

// 2진수 문자열 → 10진수
int dec = Integer.parseInt("1010", 2);  // 10
```

## 비트 연산

```java
// AND (&) - 둘 다 1일 때 1
5 & 3  // 0101 & 0011 = 0001 = 1

// OR (|) - 하나라도 1이면 1
5 | 3  // 0101 | 0011 = 0111 = 7

// XOR (^) - 다르면 1, 같으면 0
5 ^ 3  // 0101 ^ 0011 = 0110 = 6

// NOT (~) - 비트 반전
~5  // ~0101 = 1010 (2의 보수로 -6)

// 왼쪽 시프트 (<<) - 왼쪽 이동(곱하기 2)
5 << 1  // 0101 → 1010 = 10
5 << 2  // 0101 → 10100 = 20

// 오른쪽 시프트 (>>) - 오른쪽 이동(나누기 2, 부호 유지)
5 >> 1  // 0101 → 0010 = 2

// unsigned 오른쪽 시프트 (>>>) - 오른쪽 이동(부호 무시)
-1 >>> 1  // 양수 결과
```

## 비트 조작

```java
// i번째 비트 확인 (0부터 시작)
boolean getBit(int num, int i) {
    return ((num >> i) & 1) == 1;
    // 또는: return (num & (1 << i)) != 0;
}

// i번째 비트를 1로 설정
int setBit(int num, int i) {
    return num | (1 << i);
}

// i번째 비트를 0으로 설정
int clearBit(int num, int i) {
    return num & ~(1 << i);
}

// i번째 비트 토글 (반전)
int toggleBit(int num, int i) {
    return num ^ (1 << i);
}

// 오른쪽 i개 비트를 0으로 설정
int clearRightBits(int num, int i) {
    return num & (-1 << i);
}

// 왼쪽부터 i개 비트를 0으로 설정
int clearLeftBits(int num, int i) {
    return num & ((1 << i) - 1);
}
```

## 비트 사용

```java
// 짝수/홀수 판별
boolean isEven(int n) {
    return (n & 1) == 0;
}

// 2의 거듭제곱 확인
boolean isPowerOfTwo(int n) {
    return n > 0 && (n & (n - 1)) == 0;
}

// 가장 오른쪽 1비트만 남기기
int rightmostOne(int n) {
    return n & (-n);
}

// 가장 오른쪽 1비트 제거
int removeRightmostOne(int n) {
    return n & (n - 1);
}

// 두 수의 부호가 같은지 확인
boolean sameSign(int a, int b) {
    return (a ^ b) >= 0;
}

// 절댓값(음수가 아닐 때만)
int abs(int n) {
    int mask = n >> 31;
    return (n + mask) ^ mask;
}

// 최댓값(if문 없이)
int max(int a, int b) {
    return b & ((a - b) >> 31) | a & (~(a - b) >> 31);
}

// 최솟값(if문 없이)
int min(int a, int b) {
    return a & ((a - b) >> 31) | b & (~(a - b) >> 31);
}

// 두 수 교환 (변수 없이)
a ^= b;
b ^= a;
a ^= b;
```
