<div align="center">

# **소수**

1보다 큰 자연수 중에서 1과 자기 자신만을 약수로 가지는 수

</div>

## 소수 판별

`단일 수의 소수 여부 확인`

1. 일반 반복: O(N)
2. 최적화 반복: O(√N) (제곱근까지 반복, 홀수만 검사, 6k ± 1 형태만 검사)

## 에라토스테네스의 체

`특정 범위 내의 모든 소수를 찾는 알고리즘`  

`시간복잡도: O(N log log N), 공간 복잡도: O(N)`  

```
1. 2부터 N까지 모든 수 나열
2. 가장 작은 소수부터 그 배수들을 제거
3. 남은 수들이 모두 소수
```  

```
boolean[] isPrime = new boolean[n + 1];

// 초기화
for (int i = 2; i <= n; i++) {
    isPrime[i] = true;
}

// 검사
for (int i = 2; i * i <= n; i++) {
    if (isPrime[i]) {
        for (int j = i * i; j <= n; j += i) {
            isPrime[j] = false;
        }
    }
}

// 홀수만 검사 가능
```
