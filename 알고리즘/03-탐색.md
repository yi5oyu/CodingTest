<div align="center">

# **탐색(Search)**

데이터 집합에서 원하는 값을 찾는 알고리즘

</div>

## 선형 탐색

`배열의 처음부터 끝까지 순차적으로 탐색하는 방법`  
`시간복잡도: O(n)`  
`공간복잡도: O(1)`  

## 이진 탐색

`정렬된 배열에서 중간값과 비교하며 탐색 범위를 절반씩 줄여가는 찾는 방법`  
`시간복잡도: O(log n)`  
`공간복잡도: O(1)`  
`조건: 배열이 정렬되어 있어야 함`

```
[1, 3, 5, 7, 9, 11, 13, 15] 에서 7 찾기

1: [1, 3, 5, 7, |9|, 11, 13, 15]
   중간값 9 > 7 → 왼쪽 절반 탐색

2: [1, 3, |5|, 7]
   중간값 5 < 7 → 오른쪽 절반 탐색

3: [|7|]
   중간값 7 = 7 (찾음)
```

## Lower Bound / Upper Bound

`특정 값 이상/초과인 첫 번째 위치를 찾는 이진 탐색 변형`

```
[1, 2, 2, 2, 3, 4] 에서 2 탐색

기본 이진 탐색: 인덱스 1~3 중 아무거나
Lower Bound(특정 값 이상): 인덱스 1 (2 이상인 첫 위치)
Upper Bound(특정 값 초과): 인덱스 4 (2 초과인 첫 위치)

활용: 특정 값의 개수 = upperBound - lowerBound
```

```java
// Lower Bound: target 이상인 최소 위치
int lowerBound(int[] arr, int target) {
    int left = 0, right = arr.length;
    while (left < right) {
        int mid = (left + right) / 2;
        if (arr[mid] >= target) right = mid;
        else left = mid + 1;
    }
    return left;
}

// Upper Bound: target 초과인 최소 위치
int upperBound(int[] arr, int target) {
    int left = 0, right = arr.length;
    while (left < right) {
        int mid = (left + right) / 2;
        if (arr[mid] > target) right = mid;
        else left = mid + 1;
    }
    return left;
}
```

`target 이상인 첫 위치`: `int start = lowerBound(arr, target);`

`target 이하인 마지막 위치`: `int end = upperBound(arr, target) - 1;`

`target 초과인 첫 위치`: `int start = upperBound(arr, target);`

`target 미만인 마지막 위치`: `int end = lowerBound(arr, target) - 1;`

## 파라메트릭 서치

`조건을 만족하는 최솟값 또는 최댓값을 이진 탐색으로 찾는 기법`

`조건: 값이 커질수록 조건 만족 여부가 일관되게 변함 - 단조성(Monotonicity)`

```
핵심: 값을 직접 찾는 게 아니라, 답의 범위를 이진 탐색


예시: 나무 자르기
 - H 높이로 나무를 자를 때, M미터 이상 얻으려면?
 - H가 작을수록 더 많이 얻음 (단조 감소)![Uploading download.png…]()

 - H의 범위 [0, 최대높이]를 이진 탐색

H = 0  → ████████ (많음) ✅
H = 5  → ██████   (많음) ✅
H = 10 → ████     (많음) ✅
H = 15 → ██       (충분) ✅
H = 20 → ▪        (부족) ❌
H = 25 →          (부족) ❌

→ 조건을 만족하는 최대 H 찾기
```
